use std::{collections::BTreeMap, path::PathBuf};

use anyhow::Context;
use reqwest::Body;
use wasmer_api::WasmerClient;
use webc::wasmer_package::Package;

pub async fn publish(wclient: &WasmerClient, package: &Package, name: &str) -> anyhow::Result<()> {
    let mut namespace = "papps".to_string();
    // let papp = package.manifest().package.remove("papp");
    let h = package.webc_hash().context("in getting the hash")?;
    let hash_str = hex::encode(h);
    let mut name = name.to_owned();
    let session_uri = wasmer_api::query::get_signed_url_for_package_upload(
        wclient,
        None,
        Some(&hash_str),
        None,
        None,
    )
    .await?
    .context("in getting the signed url")?
    .url;
    let client = reqwest::Client::builder()
        .default_headers(reqwest::header::HeaderMap::default())
        .build()
        .unwrap();

    let res = client
        .post(&session_uri)
        .header(reqwest::header::CONTENT_LENGTH, "0")
        .header(reqwest::header::CONTENT_TYPE, "application/octet-stream")
        .header("x-goog-resumable", "start");

    let result = res.send().await?;

    if result.status() != reqwest::StatusCode::from_u16(201).unwrap() {
        return Err(anyhow::anyhow!(
            "Uploading package failed: got HTTP {:?} when uploading",
            result.status()
        ));
    }

    let headers = result
        .headers()
        .into_iter()
        .filter_map(|(k, v)| {
            let k = k.to_string();
            let v = v.to_str().ok()?.to_string();
            Some((k.to_lowercase(), v))
        })
        .collect::<BTreeMap<_, _>>();

    let session_uri = headers
        .get("location")
        .ok_or_else(|| {
            anyhow::anyhow!("The upload server did not provide the upload URL correctly")
        })?
        .clone();

    // tracing::info!("session uri is: {session_uri}");
    /* XXX: If the package is large this line may result in
     * a surge in memory use.
     *
     * In the future, we might want a way to stream bytes
     * from the webc instead of a complete in-memory
     * representation.
     */
    let bytes = package.serialize()?;

    let total_bytes = bytes.len();
    // pb.set_length(total_bytes.try_into().unwrap());
    // pb.set_style(ProgressStyle::with_template("{spinner:.yellow} [{elapsed_precise}] [{bar:.white}] {bytes}/{total_bytes} ({bytes_per_sec}, {eta})")
    //              .unwrap()
    //              .progress_chars("█▉▊▋▌▍▎▏  ")
    //              .tick_strings(&["✶", "✸", "✹", "✺", "✹", "✷", "✶"]));
    // tracing::info!("webc is {total_bytes} bytes long");

    let chunk_size = 8 * 1024;

    let stream = futures::stream::unfold(0, move |offset| {
        // let pb = pb.clone();
        let bytes = bytes.clone();
        async move {
            if offset >= total_bytes {
                return None;
            }

            let start = offset;

            let end = if (start + chunk_size) >= total_bytes {
                total_bytes
            } else {
                start + chunk_size
            };

            let n = end - start;
            let next_chunk = bytes.slice(start..end);
            // pb.inc(n as u64);

            Some((Ok::<_, std::io::Error>(next_chunk), offset + n))
        }
    });

    let res = client
        .put(&session_uri)
        .header(reqwest::header::CONTENT_TYPE, "application/octet-stream")
        .header(reqwest::header::CONTENT_LENGTH, format!("{}", total_bytes))
        .body(Body::wrap_stream(stream));

    res.send()
        .await
        .map(|response| response.error_for_status())
        .map_err(|e| anyhow::anyhow!("error uploading package to {session_uri}: {e}",))??;

    wasmer_api::query::push_package_release(
        wclient,
        Some(name.as_str().as_ref()),
        namespace.as_str(),
        &session_uri,
        Some(false),
    )
    .await?
    .context("in getting it pushed")?;

    Ok(())
}
pub fn bake(a: &[u8], name: &str) -> anyhow::Result<Package> {
    let d = tempdir::TempDir::new("papp")?;
    std::fs::write(d.path().join("/wasmer.toml"), format!(r#"
    [package]
name = "papp/{name}"
version = "0.0.0"
description = "GENERATED by portal app compiler"
entrypoint = "{name}"

[module]
name = "{name}"
source = "./$.wasm"

[[command]]
name = "{name}"
module = "{name}"
runner = "wasi"
    "#))?;
    std::fs::write(d.path().join("$.wasm"), a)?;
    return Ok(Package::from_manifest(d.path().join("/wasmer.toml"))?);
}
